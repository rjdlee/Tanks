import GameMap from './game_map';
import Explosion from 'entity/explosion';
import Collision from 'collision/collision';
import ObjectPool from 'util/object_pool';
import Event from 'event/event';

require.cache = {};

console.log( Event );
console.log( JSON.stringify( Event.prototype ) );

export default class Game
{
	constructor()
	{
		this.game_map = new GameMap();

		this.collision_pool = new ObjectPool( 3, Collision );
		this.explosion_pool = new ObjectPool( 10, Explosion );
		console.log( "BYEHI" );
		console.log( JSON.stringify( Event ) )
			// Event.listen( 'play', function ()
			// {
			// 	console.log( 'test' );
			// } );
	}

	update( dt )
	{
		this.update_tanks( dt );
		this.update_bullets( dt );
		this.update_mines( dt );
		this.update_explosions( dt );
	}

	update_tanks( dt )
	{
		let collision = collision_pool.get();

		for ( let [ id, tank ] in game_map.tanks )
		{
			if ( tank.rotation.speed !== 0 )
			{
				tank.turn( tank.rotation.speed * dt );

				for ( let [ id, wall ] of map.walls )
				{
					if ( collision.is_colliding( tank, wall ) )
						player.rotateAlongWall( collision.edge, collision.overlap );
				}

				for ( let [ id, collision_tank ] of map.tanks )
				{
					if ( collision.is_colliding( tank, collision_tank ) )
						player.rotateAlongPlayer( collision.edge.unit_vector() );
				}
			}

			if ( player.velocity.length !== 0 )
			{
				let velocity = player.velocity.clone();

				for ( let [ id, wall ] of map.walls )
				{
					if ( collision.is_colliding( tank, wall ) )
						velocity.project( collision.edge.unit_vector() );
				}

				for ( let [ id, collision_tank ] of map.tanks )
				{
					if ( collision.is_colliding( tank, collision_tank ) )
						velocity.project( collision.edge.unit_vector() );
				}

				player.move( velocity.x * dt, velocity.y * dt );

				if ( id === controller.id )
					controller.camera.moveTo( player.pos.x, player.pos.y, this.width, this.height );
			}

			// Ease towards the next position from the server
			if ( player.next_pos.length() > 0 )
			{
				var dX = player.next_pos.x,
					dY = player.next_pos.y;

				if ( Math.abs( player.next_pos.x ) > 1 )
					dX /= 10;

				if ( Math.abs( player.next_pos.y ) > 1 )
					dY /= 10;

				player.next_pos.add( -dX, -dY );

				player.move( dX, dY );
			}

			if ( Math.abs( player.rotation.nextRad ) > 0 )
			{
				var dAngle = player.rotation.nextRad;

				if ( Math.abs( player.rotation.nextRad ) > 1 )
					dAngle /= 2;

				player.rotation.next_angle -= dAngle;

				player.turn( dAngle );
			}
		}

		collision_pool.release( collision );
	}

	update_bullets( dt )
	{
		let collision = collision_pool.get();

		for ( let [ id, bullet ] of map.bullets )
		{
			let velocity_x = bullet.velocity.x,
				velocity_y = bullet.velocity.y;

			// Cancel bullets
			for ( let [ id, collision_bullet ] of map.bullets )
			{
				collision = bullet.isRectangleCollision( collision_bullet );

				if ( collision )
				{
					map.remove_bullet( bullet );
					map.remove_bullet( collision_bullet );
				}
			}

			// Explode mines
			for ( let [ id, mine ] of map.mines )
			{
				collision = bullet.isRectangleCollision( mine );

				if ( collision )
				{
					map.remove_bullet( bullet );
					map.remove_mine( mine );
				}
			}

			// Bounce off walls
			for ( let [ id, wall ] of map.walls )
			{
				collision = bullet.isRectangleCollision( wall );

				if ( collision )
				{
					bullet.bounce( collision.edge );

					velocity_x = bullet.velocity.x;
					velocity_y = bullet.velocity.y;
				}
			}

			bullet.move( velocity_x * dt, velocity_y * dt );
		}

		collision_pool.release( collision );
	}

	update_mines( dt )
	{
		for ( var [ id, mine ] of map.mines )
		{
			if ( mine.count_down( dt ) )
			{
				map.remove_mine( mine );
			}
		}
	}

	update_explosions( dt )
	{
		for ( var [ id, explosion ] of map.explosions )
		{
			if ( explosion.count_down( dt ) )
			{
				map.remove_explosion( explosion );
			}
		}
	}
}